## 关键词

**HMAC** 基于hash的消息认证码  ,在做hash操作的同时混入了HMAC密钥,因此只有拥有HMAC密钥才能得到正确的HMAC值.在TPM中主要用作证明用户是否拥有对TPM资源实体的使用权限.

举例:一个TPM中的资源对象(签名密钥)的使用权限可能与一个HMAC的签名密钥有关,这个密钥是用户和TPM都知道的.用户在是用这个TPM对象之前需要首先构造一个命令消息,然后由对象的权限信息派生出HMAC密钥,接着使用HMAC密钥对命令消息做HMAC操作。当TPM收到命令消息和前述的HMAC操作结果之后，使用同样的方法产生HMAC结果。如果两个HMAC值相同就说明命令没有在传输过程中被修改，即命令消息具备完整性。并且命令的发送者确实知道与这个TPM对象关联的HMAC密钥，这意味者命令发送者是经过授权的。这就是一个基于HMAC的授权过程。

**KDF** 密钥生成函数,TPM被设计成可以通过一个秘密信息生成不同的密钥。这个秘密信息称作种子，而算法通过密钥生成函数和这个种子来生成相对应的密钥。TPM就是通过这样的方式来生成对称和非对称密钥的。具体的实现上来说，就是用种子（seed）作为HMAC密钥对一些数据（具体算法相关）做HMAC操作，其结果就是密钥。

**认证或授权凭证** 数据在进出TPM的过程中，HMAC保证了数据的完整性。虽然完整性保证了，但如果数据是以明文的方式存储在TPM之外的地方还是会有问题。这个时候常常需要对称加密密钥对原始数据进行加密以后再送到TPM之外。

**对称加密密钥**  对称加密密钥是一种应用于对称加密算法的密钥。对称加密算法使用相同的密钥做加解密操作。HMAC操作也是一样，HMAC操作对象是数据的哈希，对称加密算法是数据本身.

在TPM中有三种不同的应用:

- 保证TPM数据的机密性,一般来说对称密钥不会存储在TPM以外的地方,所以只有TPM可以访问和创建他们.但是当因为存储控制受限的,而将对称密钥存储到TPM之外时,他首先会被只有TPM能访问的对称密钥加密.
- 加密进出TPM的通讯数据.此时的对称密钥由消息发送者和TPM都知道的秘密信息派生而来.通讯过程中的数据都将会被这个密钥加密.
- 把TPM当作一个对称加解密协处理器。因为TPM完全具备对称加解密的功能，这是完全可行的。你可以将一个对称密钥导入TPM，然后让TPM使用这个密钥来对数据加密。因为TPM的运算速度很慢，所以单纯的加解密功能通常用于少量数据加密。

**对称密钥的模式**  对称加密算法通常用于对成块的大量数据加密.但当数据已成块的模式被加密的时候,需要解决下面两个问题:

- 如果数据块仅仅使用密钥来加密，这叫做ECB模式。因为使用这种模式时，相同的数据快产生的结果总是一样的。当一个位图以ECB的模式被加密时最终的结果是颜色变化（wiki）。这对于大量的数据没有作用，因为数据量变大以后总会出现相同的数据内容，所以最终的密文会有一定程度的体现，这是不安全的.(TPM还支持其他的模式：CBC，CFB，OFB，CTR)
- 有一些模式要求输出必须是算法要求的成块大小，CBC就是这样。如果输入的数据大小与块大小不是整数比例关系，算法将会填充原有的数据块来满足要求。所以这就造成了输出数据大小比输入数据大的情况。对于有些应用来说这不是问题，但是不适合一些明确要求输入输出大小必须一致的应用，比如TPM命令数据流的加密。

这就引出一个非常重要但常常被忽略的问题。加密仅仅提供保密性保护，但是不能提供完整性和认证功能。为了实现后者，TPM会对加密后的数据做HMAC操作而不是依赖加密后的数据看起来是不是对的。因此在实际应用中，对数据的解密总是在验证HMAC之前。

另外，机密并不能证明消息是最近产生的，举例来说有可能是很久之前的一次相同的操作中产生的（回忆以下前面介绍的防止重放）。这时候就需要nonce了

**Nonce** 只能使用一次的随机数,用来阻止重放攻击,为了保证消息不被有效地重复利用,消息的接受者会产生一个nonce发送给消息发送者,发送者将nonce包含在消息中,因为消息发送者不能预测接收者如何选择nonce,所以发送无法事先准备好一个有效的消息.nonce并不是简单地包含在消息中,当用户向TPM发送命令并接收到响应后，Nonce同时也结合HMAC向用户证明用户接收的结果确实来自于真实的TPM。

简述在TPM中的流程:  在TPM中,nonce会被包含在HMAC的计算中.消息涉及的操作完成之后nonce值将会被改变,攻击者如果想继续利用原来的nonce的话,TPM再次验证HMAC将会失败,因为TPM完成了这个消息的操作之后就会对这个nonce进行'遗忘',所以再次验证失败才是正常现象.

**非对称密钥** 非对称密钥主要用于数字身份和密钥管理中,非对称密钥分为两部分,只有一方可以知道的私钥和可以对所有人公布的公钥. 

常见用法: 在加解密应用中，公钥加密数据，私钥解密。在数字签名应用时则相反，私钥用于签名，公钥用于验签。我们将分别介绍其中的细节。

常见非对称密钥算法:

- RSA : 将大数转换为大素数的函数作为单项函数.
  - RAS用于密钥加密: 得到对方的公钥(很容易),加密即可,私钥拥有者解密. 但实际应用中很少用到非对称密钥做加密操作,一般都是用对称密钥加密数据,然后对对称密钥进行加密.这样接受者首先用私钥解密对称密钥,对称密钥解密数据信息. 不用非对称密钥加密的原因主要是非对称加密算法很慢.
  - RSA用于数字签名: 数字签名和HMAC很像,但是它有额外的特性.签名者用私钥对数据进行加密操作就得到了一个数字签名,验签就是用公钥解密签名数据. 数字签名可以保证消息的完整性和真实性,HMAC也有相同的功能,但是基于非对称算的数字签名有着更多的特性,首先,就像上边讲的,HMAC的消息只有拥有HMAC密钥的人才能验证,而非对称算法的因为公钥是公开的,所以是一对多的关系. 并且 签名理论上只有拥有私钥的人才能生成,所以消息接受者使用某一个公钥验证一个签名的时候,第三方就会认为只有拥有私钥的拥有者可以产生签名(不可抵赖性).但是HMAC就做不到这一点,因为HMAC的密钥是双方同时知道的一个秘密,接受者完全可以靠自己生成一个,然后说是对方签名的.  常见的使用模式为: 签名者先对消息hash操作,然后得到消息的摘要,在对摘要签名,接受者接收到消息时,首先会公钥解密出消息的摘要,然后使用和签名者相同的hash算法对消息再做一次摘要,对比摘要值. 这种签名之所以有效,是由于安全hash算法特有的属性,攻击者不能构造出一个和元消息相同摘要的不同消息.
- ECC: 基于有限域椭圆曲线. ECC密钥长度远小于RSA密钥长度,ECC密钥强度是其密钥比特长度的一般.
  - ECDH用于密钥交换: 事实上,当使用ECC对数据加解密的时候,使用的是ECDH算法. ECC和RSA在数据加解密上面最大的不同是,ECDH需要两步而RSA只需要一步,具体到TPM就是,RSA加密就是用TPM中RSA的公钥加密数据,而基于TPM的ECDH有两步: 用软件的方法生成另一个ECDH密钥,然后用这个新生成的ECDH私钥和TPM的ECDH公钥产生一个临时的随机数,然后用KDF把随机数转变为一个对称密钥. 简单描述来说就是,RSA加密对称密钥,而ECC直接自己生成对称密钥.
  - ECDSA用于数字签名: ECDSA是通过ECC算法生成的签名算法. 他用于私钥签名公钥验证,这一点和RSA相同.不同的是,RSA可以签名任何现有hash算法的输出结果,但是对于ECDSA来说,一般是使用相互匹配的hash算法,如SHA-256对应ECC-256,SHA-384对应ECC-384,如果使用ECC-384密钥签名SHA-512的结果,最终ECDSA只会使用其中的384比特位的hash值.
    - 不过所有的数字签名协议都会面临着一个问题,接受者必须确认他们使用的公钥是来自数字签名的人.换句话说，怎么防止攻击者自己生成一对儿公私密钥，然后给接收者发送公钥和一个对应私钥的签名，签名的数据中包含以其他人身份的非法操作（这种情况下签名可以通过，但签名的数据是恶意的）。是时候让公钥证书登场了。

**公钥证书** 证书本身就是非对称密钥协议的一部分,主要解决的问题就是确保公钥可信,如果你都不确保发送给你公钥的人的真实身份,那这仅仅只是做了一次非对称的解密的过程,不能称之为数字签名验证.TPM中也存在类似的问题,TPM需要有一种机制证明给公钥使用者,这个密钥确实是来自于正在交互的真实TPM.

这个问题的解决办法就是数字证书,一个证书主要包括一个被认证过的公钥和密钥对儿相关的属性。 这个证书本身会被一个证书认证机构的私钥签名。一个证书认证机构的公钥也可能被另外一个证书认证机构签名过，从而组成一个证书组织架构（又叫作证书链）。最终这样的证书链会停在一个根证书的地方。根证书中包含的公钥是不需要被认证的，换句话说是被证书链的验证者无条件相信的。

在TPM中有如下几种认证过程:

- TPM厂商和平台厂商可能会在交付用户时提供他们的背书密钥（EndorsementKey），这些密钥（公钥）就是对应的证书。其中，TPM厂商的证书用于证明：厂商的背书密钥存在于一个确实由这个厂商生产的真实TPM中。平台厂商的证书则用于证明：平台的背书密钥确实存在于平台上的TPM中，并且平台支持相关TPM功能。这两种证书的格式就是X.509格式，因为这个格式被广泛使用。
- 如果一个TPM密钥及其证书被描述成一个签名密钥。那么这个密钥可以被用于认证其他的密钥确实存在于TPM中并且具备一定的属性。TPM2.0有相关的命令来创建证书，但是因为X.509格式对于资源受限的TPM来说太复杂了，TPM使用一种自定义的证书格式。

本质上说，数字证书依赖于证书认证机构的完整真实性。证书认证机构是一个被证书创建者和使用者信任的中立机构。

## TPM资源实体 

一个TPM2.0资源实体是TPM内部可以通过handle直接引用的内容。这个概念包含了对象的概念，因为TPM规范使用对象来引用一个实体的子集。

将简要介绍这些实体的类型：永久实体（组织架构，字典攻击锁定机制，和PCR）；与永久实体类似的非易失性实体（NVRAM索引）；对象（秘钥和数据）；以及易变的实体（各种各样的会话）。

**永久实体** 一个永久实体的handle是由TPM规范好的，这些handle不能被创建和删除。TPM1.2中，PCR和所有者是唯一的永久实体；根存储秘钥（SRK）有固定的handle，但不是永久实体。TPM2.0中，存在更多的实体类型：三个固定的组织架构、一个临时组织架构、字典攻击锁定复位，保留handle，明文口令授权会话和平台组织架构的NV使能。

- **固定的组织架构**：平台-->TPM_RH_PLATFORM（0x4000000C）、存储-->TPM_RH_OWNER（0x40000001）、背书-->TPM_RH_ENDORSEMENT（0x4000000B）。访问需要被授权，每一个都有一个授权和策略。经过管理员的授权以后就可以改变相应的组织架构。组织架构的授权值和策略可以被更改，但是不论我们引用一个组织架构，都是指的同一个TPM资源实体。固定的组织架构永远不能被删除，但是它们可以被自己的管理员或者平台管理员关闭。这三种组织架构可以包含相关的秘钥链和数据，清除组织架构就能清除其中的秘钥和 数据。

- **临时的组织架构**：固定的handle来引用：TPM_RH_NULL（0x40000007）授权值和策略都是空的，这个临时的组织架构本身是永久存在的，但是不能被删除，每个上电周期都会被自动清除。

- **字典攻击复位** 字典攻击锁定机制有一个固定的handleTPM_RH_LOCKOUT（0x4000000A）。它同样有一个授权和policy。与之前的三个固定的组织架构一样，这个授权可以被响应的管理员修改。不同的是，它是一个不包含秘钥的组织架构，当字典攻击触发锁定时，可以使用此机制用于复位。它还可以清楚TPM_RM_OWNER组织架构。通常情况下它充当TPM存储组织架构的IT管理员。

  - 示例：失败次数复位

    TPM被配置成输入口令失败5次之后将锁定这个用户24小时。锁定期间所有受到字典攻击保护的资源都不能被授权。用户需要说服IT管理员相信这个锁定不是因为攻击，仅仅是因为密码输入错误。管理可以使用锁定授权复位失败计数器，这样一来用户就不需要等待24小时。

- **平台配置寄存器（PCR）** TPM拥有一些使用索引来访问的PCR。根据平台相关规范的定义，PCR可以使用一种或者多种算法。它们同样也有授权值和policy，这个规范来选择（通常是NULL），授权值和policy可以用于通过PCR扩展（extend）来改变PCR的值。读取PCR的值不需要任何授权。 PC客户端平台规定至少要有24个PCR。只有一个PCR bank是强制的，bank可以在系统启动时被配置为使用SHA-1或者SHA-256算法。

  - 因为PCR是一种永久实体，所以没有创建或者删除PCR的命令；你只能修改它的属性或者值。

- **口令授权会话** TPM有一个会话也是永久性的，它就是口令授权会话的handle-->TPM_RS_PW（0x40000009），用户可以使用这个handle做明文口令授权。

- **平台NV使能** handle（0x4000000D）TPM_RH_PLATFORM_NV控制着平台组织架构的NV使能。当清除使能位后，所有平台组织架构下NV索引的访问都将被拒绝。

  - 需要说明的是，NV索引可以隶属于平台组织架构或者存储组织架构。存储组织架构本身控制着其NV索引的使能，但是平台组织架构并不控制平台的NV索引使能。所以平台NV的使能就是一个隔离控制的案例。这样就实现了平台组织架构下的密钥等资源与平台NV索引的独立控制。

**NV索引** 一个NVRAM索引就是一个非易失性TPM实体。TPM内部有一定的非易失性存储空间供用户配置用于数据存储。当配置完成后，这个空间就具备一个索引和一组属性，索引和属性是用户可以选择的。

NVRAM索引同时具有授权值和授权策略。NV索引的拥有者可以改变授权值，但是不能改变授权策略，授权策略一旦被创建就不能再修改。如果NVRAM与平台相关，那么当平台组织架构被清除时相关的NVRAM索引也将被删除。

对象和NVRAM类似，他们都属于某一个组织架构，都自己的数据和授权机制，但是对象的属性相对较少。

**对象** 一个TPM对象可能是密钥或者其他数据。所有的对象都隶属于一个组织架构。TPM对象也都有相关的授权数据和授权策略。与NV索引相同的一点是，一个对象的策略一旦被创建后就不能再修改。

当TPM对象应用于命令时，命令被分为管理和用户两类。在创建TPM对象时，用户可以决定在使用这个对象的命令中，哪一些命令可以通过授权数据来使用，哪一些只能使用策略。但是需要特别提醒的是：对于有些命令来说，不管密钥创建的时候配置什么样的属性，它们都只能通过策略来授权执行。

跟NVRAM索引相似，所有的TPM对象都隶属于以下四种组织架构中的一种：平台，存储，背书，或者NULL。当一个组织架构被清除时，它所有的对象也都将被删除。

通常来说，大部分的TPM对象都是密钥。

**持续性的实体** 一个持续性的实体就是一个组织架构的所有者要求TPM在上电周期之间保留在TPM中的对象。它与永久实体的不同是相关组织架构的拥有者可以清除持续性实体。因为TPM的持续性内存空间有限，所以我们应该节约使用持续性实体。

通常情况下，主存储密钥比如SRK，受限的主签名密钥比如身份认证密钥AIK，以及背书密钥是TPM中仅有的可持续性实体。

**实体名称**  名称是一个TPM实体唯一的身份标示。对于永久性的实体来说（如PCR和组织架构的handle），因为他们的handle永远不会变，所以handle就是它们的名称。对于其他的实体（如NV索引和加载的对象）来说，它们的名称实际上是他们各自的公开数据的哈希值。TPM设备本身和API调用者在授权时会独立地计算实体的名称。

## 组织架构



